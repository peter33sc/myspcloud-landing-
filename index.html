  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SP Cloud — Decentralized. Lightning‑Fast. Beautiful.</title>
    <meta name="description" content="SP Cloud: decentralized cloud with proprietary bandwidth optimization, 95% lossless compression, realtime collaboration, high‑res calls & streaming. Pre‑order now." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="icon" href="logo.png" type="image/png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
      <style>
      :root {
        --bg:#0e0b16;
        --ink:#f7f7fb;
        --muted:#c3bce6;
        --accent1:#a86bff;
        --accent2:#ff5fb7;
        --accent3:#ffd166;
        --accent4:#66e0ff;
        --glass: rgba(255,255,255,0.08);
        --glass-strong: rgba(255,255,255,0.14);
        --radius: 20px;
        --shadow: 0 10px 30px rgba(0,0,0,.35);
        --maxw: 1180px;
      }
      *{box-sizing:border-box}
      body {
        font-family: Inter, system-ui, sans-serif;
        color:var(--ink);
        margin:0;
        background:
          radial-gradient(1800px 900px at 90% -10%, rgba(255,170,0,.12), transparent 60%),
          radial-gradient(1400px 800px at -10% 10%, rgba(87,0,255,.25), transparent 60%),
          linear-gradient(160deg, #1a102b 0%, #0f0b21 45%, #0a0920 100%);
      }
      a{color:inherit;text-decoration:none}
      .gradient-txt{background:linear-gradient(90deg,var(--accent4),var(--accent1),var(--accent2));-webkit-background-clip:text;color:transparent}
      .btn{display:inline-flex;align-items:center;gap:.6rem;padding:.9rem 1.1rem;border-radius:999px;font-weight:700;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;border:0;box-shadow:var(--shadow);cursor:pointer;transition:transform .15s ease,filter .2s ease}
      .btn:hover{transform:translateY(-2px);filter:brightness(1.1)}
      .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.25)}
      .container{width:100%;max-width:var(--maxw);margin:auto;padding:0 20px}
      .card{background:var(--glass);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.12);border-radius:var(--radius);box-shadow:var(--shadow)}
      h1{font-size:clamp(2.2rem,5vw,4rem);margin:10px 0 14px;font-weight:900;line-height:1.05}
      p.lead{font-size:1.2rem;color:var(--muted);line-height:1.6}

      /* Pricing section */
      .pricing {display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:24px;margin-top:40px;}
      .price-card {padding:30px;text-align:center;background:var(--glass-strong);border-radius:var(--radius);}
      .price-card h3{font-size:1.4rem;margin:0 0 10px}
      .price-card .price{font-size:2.2rem;font-weight:900;margin-bottom:8px}
      .price-card .note{color:var(--muted);font-size:.95rem;margin-bottom:14px}

      /* Form */
      .form-wrap{display:block;grid-template-columns:1fr 1fr;gap:28px}
      form{padding:24px}
      label{font-weight:700;margin:8px 0 6px;display:block}
      .input,textarea,select{width:100%;padding:14px 16px;border-radius:14px;color:#fff;background:rgba(0,0,0,.3);border:1px solid rgba(255,255,255,.25);font-size:1rem}
      .input:focus{border-color:var(--accent2);box-shadow:0 0 0 4px rgba(255,95,183,.15)}
      .note{font-size:.9rem;color:var(--muted)}
      .success,.error{display:none;margin-top:10px;font-weight:700}
      .success{color:#b1f5c4}.error{color:#ffb2c2}

      footer{padding:40px 0;text-align:center;color:var(--muted);font-size:.9rem}
      @media(max-width:960px){.form-wrap{grid-template-columns:1fr}}
    </style>
    <style>
      :root{
        --bg:#0e0b16;
        --ink:#f7f7fb;
        --muted:#c3bce6;
        --accent1:#a86bff; /* purple */
        --accent2:#ff5fb7; /* pink */
        --accent3:#ffd166; /* soft yellow */
        --accent4:#66e0ff; /* soft blue */
        --glass: rgba(255,255,255,0.08);
        --glass-strong: rgba(255,255,255,0.14);
        --radius: 20px;
        --shadow: 0 10px 30px rgba(0,0,0,.35);
        --maxw: 1180px;
      }
      *{box-sizing:border-box}
      a{
        text-decoration: none;
      }
      html,body{margin:0;padding: 0; overflow-x: hidden;}
      body{
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        color:var(--ink);
        background:
          radial-gradient(1800px 900px at 90% -10%, rgba(255,170,0,.12), transparent 60%),
          radial-gradient(1400px 800px at -10% 10%, rgba(87, 0, 255,.25), transparent 60%),
          linear-gradient(160deg, #1a102b 0%, #0f0b21 45%, #0a0920 100%);
        overflow-x:hidden;
      }
      a{color:inherit}
      .gradient-txt{background:linear-gradient(90deg,var(--accent4),var(--accent1),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent}
      .btn{
        display:inline-flex;align-items:center;gap:.6rem;
        padding:.9rem 1.1rem;border-radius:999px;font-weight:700;
        background:linear-gradient(90deg,var(--accent1),var(--accent2));
        color:#fff;border:0;box-shadow:var(--shadow);cursor:pointer;
        transition: transform .15s ease, filter .2s ease;
      }
      .btn:hover{transform: translateY(-2px); filter: brightness(1.08)}
      .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.25)}
      .container{width:100%;max-width:var(--maxw);margin-inline:auto;padding:0 20px}
      .hero {
        position: relative;
        padding: 80px 0 80px;
        margin-top: -40px;

        /* Softer continuation instead of a new page */
        background: linear-gradient(
          180deg,
          rgba(10,9,32,0) 0%,
          rgba(10,9,32,0.30) 25%,
          rgba(10,9,32,0.75) 60%,
          rgba(10,9,32,1) 100%
        );

        backdrop-filter: blur(6px);
        transition: opacity .6s ease, transform .6s ease;
      }

      .hero {
        opacity: 0;
        transform: translateY(40px);
      }
      .hero.in-view {
        opacity: 1;
        transform: translateY(0);
      }


      .hero::before{
        content:"";
        position:absolute;
        left:0;right:0;top:-160px;
        height:160px;
        background:linear-gradient(180deg, rgba(10,9,32,0), rgba(10,9,32,0.85));
        z-index:-1;
        pointer-events:none;
      }
      .hero::after{content:"";position:absolute;inset:auto -240px -180px -240px;height:520px;z-index:-1;
        background: radial-gradient(50% 60% at 50% 40%, rgba(255,95,183,.28), transparent 70%),
                    radial-gradient(50% 60% at 70% 30%, rgba(102,224,255,.18), transparent 70%),
                    radial-gradient(60% 70% at 40% 70%, rgba(168,107,255,.30), transparent 70%);
        filter: blur(60px);opacity:.8}
      #canvas-container{
        position: relative;
      }
      #canvas-container::after{
        content:"";
        position:absolute;
        left:0;right:0;bottom:-2px;
        height:220px;
        background:linear-gradient(180deg, rgba(10,9,32,0), #0f0b21 60%, #120d26 100%);
        z-index:-50;
        pointer-events:none;
      }
      .grid{display:grid;gap:26px}
      .hero-grid{grid-template-columns: 1.2fr .8fr;align-items:center}
      .card{background:var(--glass);backdrop-filter: blur(10px);border:1px solid rgba(255,255,255,.12);border-radius:var(--radius);box-shadow:var(--shadow)}
      .logo-row{display:flex;align-items:center;gap:14px}
      .logo{width:54px;height:54px;border-radius:12px;background: linear-gradient(135deg, rgba(168,107,255,.3), rgba(255,95,183,.3)); display:grid;place-items:center;overflow:hidden}
      .logo img{width:100%;height:100%;object-fit:contain}
      h1{font-size: clamp(2.2rem, 5vw, 4rem);line-height:1.05;margin:10px 0 14px;font-weight:900}
      p.lead{font-size: clamp(1.05rem, 1.6vw, 1.2rem);line-height:1.6;color:var(--muted)}
      .badges{display:flex;flex-wrap:wrap;gap:10px;margin:18px 0 26px}
      .badge{display:inline-flex;align-items:center;gap:6px;padding:.5rem 1rem;border-radius:999px;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,0.1);font-weight:600;font-size:.85rem;backdrop-filter:blur(5px);transition:all 0.3s ease}
      .badge i{font-size:1rem;color:var(--accent4)}
      .media{padding:10px;}
      .media img{width:100%;height:auto;display:block;border-radius:18px}

      /* Feature section */
      section{padding:50px 0}
      .section-title{font-size: clamp(1.6rem, 3vw, 2.2rem);margin:0 0 10px;font-weight:800}
      .section-sub{color:var(--muted);margin:0 0 28px}
      .features{grid-template-columns:repeat(3,1fr)}
      .feature{padding:22px}
      .feature h3{margin:0 0 8px;font-size:1.1rem}
      .feature p{margin:0;color:#d9d6ef}

      /* Stats strip */
      .stats{display:grid;grid-template-columns:repeat(4,1fr);gap:16px;margin-top:30px}
      .stat{padding:20px;border-radius:16px;background:linear-gradient(135deg,rgba(168,107,255,.22),rgba(255,95,183,.18));border:1px solid rgba(255,255,255,.16)}
      .stat .num{font-size:1.9rem;font-weight:900}
      .stat .cap{color:#e9e7ff;opacity:.85}

      /* Tools gallery */
      .tools{grid-template-columns:repeat(4,1fr)}
      .tool{padding:18px;display:flex;flex-direction:column;gap:10px}
      .tool strong{font-size:1rem}

      /* Preorder form */
      .form-wrap{display:block;width:100%;max-width:1200px;margin:0 auto;padding:0 20px}
      @media (min-width: 1024px) {
        .form-wrap{display:grid;grid-template-columns:1.1fr .9fr;gap:28px;align-items:stretch}
      }
      form{padding:24px;margin-bottom:30px}
      label{display:block;font-weight:700;margin:8px 0 6px}
      .input, select, textarea{width:100%;padding:14px 16px;border-radius:14px;color:#fff;
        background:rgba(0,0,0,.3);border:1px solid rgba(255,255,255,.25);outline:none;
        transition:border .15s ease, box-shadow .15s ease;font-family: Inter, sans-serif;font-size:1rem}
      .input:focus, select:focus, textarea:focus{border-color:var(--accent2);box-shadow:0 0 0 4px rgba(255,95,183,.15)}
      select{appearance:none;-webkit-appearance:none;-moz-appearance:none;cursor:pointer;background:rgba(0,0,0,.4)}
      select::-ms-expand{display:none}
      .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
      .terms{display:flex;align-items:flex-start;gap:10px;margin:10px 0 6px;font-size:.95rem;color:#dcd7ff}
      .terms input{margin-top:2px}
      .note{font-size:.85rem;color:var(--muted)}
      .success{display:none;margin-top:10px;color:#b1f5c4;font-weight:700}
      .error{display:none;margin-top:10px;color:#ffb2c2;font-weight:700}

  .hamburger {
        display: none;
        flex-direction: column;
        justify-content: space-around;
        width: 30px;
        height: 30px;
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
      }
      .hamburger span {
        width: 100%;
        height: 3px;
        background: var(--ink);
        border-radius: 2px;
        transition: all 0.3s ease;
      }
      .hamburger.active span:nth-child(1) {
        transform: rotate(-45deg) translate(-5px, 6px);
      }
      .hamburger.active span:nth-child(2) {
        opacity: 0;
      }
      .hamburger.active span:nth-child(3) {
        transform: rotate(45deg) translate(-5px, -6px);
      }
      
      .mobile-menu.active {
        display: flex !important;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      
      .mobile-menu-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        text-align: center;
      }
      
      .mobile-menu-content a {
        color: var(--ink);
        font-size: 1.2rem;
        padding: 10px 20px;
        border-radius: 8px;
        transition: background 0.3s ease;
      }
      
      .mobile-menu-content a:hover {
        background: var(--glass);
      }
      
      .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: var(--ink);
        font-size: 2rem;
        cursor: pointer;
      }
      .mobile-menu {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(14, 11, 22, 0.95);
        z-index: 1000;
        padding: 20px;
        box-sizing: border-box;
        height: 100vh;
        background: linear-gradient(135deg, var(--bg) 0%, rgba(14, 11, 22, 0.9) 50%, var(--bg) 100%);
        background-size: 400% 400%;
        animation: gradientShift 8s ease infinite;
        backdrop-filter: blur(20px);
        z-index: 1000;
        transform: translateY(-100%);
        transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        display: flex;
        align-items: center;
        justify-content: center;
        border-bottom: 2px solid rgba(168, 107, 255, 0.3);
        box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.5);
      }
      .mobile-menu.active {
        transform: translateY(0);
      }
      .mobile-menu-content {
        display: flex;
        flex-direction: column;
        gap: 40px;
        text-align: center;
        padding: 20px;
        animation: fadeInUp 0.8s ease-out 0.2s both;
      }
      .mobile-menu a {
        font-size: 1.6rem;
        font-weight: 700;
        color: var(--ink);
        text-decoration: none;
        padding: 20px 25px;
        border-radius: var(--radius);
        background: linear-gradient(135deg, var(--glass), var(--glass-strong));
        transition: all 0.4s ease;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
      }
      .mobile-menu a::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 95, 183, 0.4), rgba(102, 224, 255, 0.4), transparent);
        transition: left 0.6s ease;
      }
      .mobile-menu a::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, rgba(168, 107, 255, 0.2), transparent 70%);
        opacity: 0;
        transition: opacity 0.4s ease;
      }
      .mobile-menu a:hover::before {
        left: 100%;
      }
      .mobile-menu a:hover::after {
        opacity: 1;
      }
      .mobile-menu a:hover {
        background: linear-gradient(135deg, var(--accent1), var(--accent2));
        color: #fff;
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 40px rgba(168, 107, 255, 0.4);
        border-color: var(--accent2);
      }
      .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: linear-gradient(45deg, var(--accent1), var(--accent2));
        border: none;
        font-size: 2.5rem;
        color: #fff;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1001;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 5px 15px rgba(168, 107, 255, 0.3);
        animation: pulse 2s infinite;
      }
      .close-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(255, 95, 183, 0.5);
      }
      @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      /* Animations for new section */
      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(30px); }
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes slideInLeft {
        from { opacity: 0; transform: translateX(-50px); }
        to { opacity: 1; transform: translateX(0); }
      }
      @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 0 20px rgba(168,107,255,0.5); }
        50% { transform: scale(1.03); box-shadow: 0 0 30px rgba(168,107,255,0.8); }
        100% { transform: scale(1); box-shadow: 0 0 20px rgba(168,107,255,0.5); }
      }
      @keyframes pulseGlow {
        0%, 100% { box-shadow: 0 0 20px rgba(102, 224, 255, 0.3); }
        50% { box-shadow: 0 0 40px rgba(102, 224, 255, 0.6); }
      }
      .animate-on-scroll {
        opacity: 0;
        transform: translateY(50px);
        transition: opacity 0.6s ease, transform 0.6s ease;
      }
      .animate-on-scroll.in-view {
        opacity: 1;
        transform: translateY(0);
      }
      @media (max-width:768px) {
        .hamburger {
          display: flex;
        }
        nav .btn {
          display: none;
        }
        .logo-row strong {
          font-size: 1.2rem;
        }
      }
      @media (max-width:960px){
        .hero-grid{grid-template-columns:1fr}
        .features{grid-template-columns:1fr 1fr}
        .tools{grid-template-columns:1fr 1fr}
        .form-wrap{grid-template-columns:1fr}
        .stats{grid-template-columns:1fr 1fr}
      }
      @media (max-width:560px){
        .features,.tools{grid-template-columns:1fr}
        .row{grid-template-columns:1fr}
      }

      .smooth-hero {
    position: relative;
    padding: 120px 0 120px;
    text-align: center;
    transform: translateY(40px);
    opacity: 0;
    transition: all .8s ease;
    
    background: linear-gradient(
      180deg,
      rgba(10,9,32,0) 0%,
      rgba(10,9,32,0.4) 35%,
      rgba(10,9,32,0.8) 75%,
      rgba(10,9,32,1) 100%
    );
    backdrop-filter: blur(8px);
  }

  .smooth-hero.in-view {
    transform: translateY(0);
    opacity: 1;
  }

  /* Centered inner block */
  .hero-inner {
    max-width: 780px;
    margin: auto;
    padding: 0 24px;
  }

  /* Title */
  .hero-title {
    font-size: clamp(2.4rem, 5vw, 3.8rem);
    line-height: 1.15;
    font-weight: 900;
    margin-bottom: 18px;
  }

  /* Subtitle */
  .hero-sub {
    font-size: 1.2rem;
    color: var(--muted);
    margin-bottom: 32px;
    line-height: 1.7;
  }

  /* Buttons */
  .hero-buttons {
    display: flex;
    justify-content: center;
    gap: 18px;
    flex-wrap: wrap;
  }
  /* Scroll Indicator */
  #scroll-indicator {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 34px;
    color: #ffffff;
    opacity: 0.8;
    animation: scrollBounce 2s infinite ease-in-out;
    z-index: 50;
    cursor: pointer;
    transition: opacity 0.4s ease;
  }

  #scroll-indicator.hidden {
    opacity: 0;
    pointer-events: none;
  }

  @keyframes scrollBounce {
    0% { transform: translate(-50%, 0); }
    50% { transform: translate(-50%, 10px); }
    100% { transform: translate(-50%, 0); }
  }
  @media (max-width: 600px) {
    #landmark-info {
      transform: translateX(-50%) translateY(10px) !important;
      width: 90% !important;
      padding: 30px 25px !important;
      bottom: 10% !important;
    }

    #landmark-title {
      font-size: 1.6rem !important;
    }

    #landmark-desc {
      font-size: 1.1rem !important;
      line-height: 1.55 !important;
    }
  }


    </style>
  </head>
  <body>
    <!-- 3D Background Canvas -->

    
    <!-- Main Content -->
    <div style="position: relative; z-index: 1; min-height: 100vh; overflow-x: hidden; background: transparent;">

    <canvas id="background-particles" style="
    position: fixed;
    top:0; left:0;
    width:100vw; height:100vh;
    pointer-events:none;
    z-index:-2000;
  "></canvas>

    
    <header class="container" style="z-index:100; position: fixed; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem 1rem; max-width: 1400px; margin: 0 auto; width: 100%; left: 50%; transform: translateX(-50%);">
      <nav class="card" style="display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-radius:999px; width: 100%; max-width: 1400px;">
        <div class="logo-row">
          <div class="logo">
            <!-- Replace src with your path. Example local path: ./assets/sp_logo.png -->
            <img src="logo.png" alt="SP Cloud logo" />
          </div>
          <strong style="letter-spacing:.5px">SP <span class="gradient-txt">Cloud</span></strong>
        </div>
        <div style="display:flex;gap:10px;align-items:center">
          <a class="btn ghost" href="#features">Features</a>
          <a class="btn ghost" href="#tools">Tools</a>
          <a class="btn" href="#get-app">Get the App</a>
        </div>
        <!-- Hamburger Menu for Mobile -->
        <button class="hamburger" aria-label="Toggle mobile menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </nav>
      <!-- Mobile Menu -->
      <div class="mobile-menu" id="mobileMenu">
        <button class="close-btn" onclick="closeMobileMenu()" aria-label="Close mobile menu">&times;</button>
        <div class="mobile-menu-content">
          <a href="#features" onclick="closeMobileMenu()">Features</a>
          <a href="#tools" onclick="closeMobileMenu()">Tools</a>
          <a href="#get-app" onclick="closeMobileMenu()">Get the App</a>
        </div>
      </div>
    </header>
    <div id="canvas-container" style="position: relative; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1000; overflow: hidden; background: linear-gradient(160deg, #1a102b 0%, #0f0b21 45%, #0a0920 100%);">
      <div id="scene-container" style="width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0;">
              <!-- Scroll Icon -->
        <div id="scroll-indicator">
          <i class="fas fa-chevron-down"></i>
        </div>

        <div id="quote-overlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; max-width: 90%; z-index: 10;">
          <div class="quote-card" style="background: rgba(10, 9, 32, 0.9); backdrop-filter: blur(16px); padding: 40px 60px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 25px 70px rgba(0,0,0,0.45); max-width: 820px; opacity: 0; transform: translateY(30px) scale(0.95);">
            <p style="font-size: 2.2rem; font-weight: 300; line-height: 1.4; margin: 0 0 20px 0; background: linear-gradient(90deg, #fff, #e0e0ff); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 2px 10px rgba(0,0,0,0.2);">
              "The fastest cloud ever—95% smaller files, 5ms latency, real-time streaming, editing, and collaboration"
            </p>
            <div class="quote-divider" style="height: 3px; width: 100px; background: linear-gradient(90deg, var(--accent4), var(--accent1)); margin: 0 auto 10px; border-radius: 3px; transform-origin: center;"></div>
            <p style="font-size: 1.1rem; color: #c3bce6; margin: 20px 0 0 0; opacity: 0.9;">Your entire digital life samaller and yours on SP Cloud </p>
          </div>
        </div>
        <div id="landmark-info" style="position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%) translateY(20px); background: rgba(0,0,0,0.8); padding: 25px 40px; border-radius: 15px; max-width: 600px; text-align: center; opacity: 0; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.3); transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 10; transform-style: preserve-3d; perspective: 1000px;">
          <h3 id="landmark-title" style="margin: 0 0 10px 0; color: var(--accent4); font-size: 1.8rem; font-weight: 700; text-shadow: 0 0 15px rgba(102, 224, 255, 0.5); letter-spacing: 0.5px; transform-style: preserve-3d; backface-visibility: hidden; transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);">
          </h3>
          <p id="landmark-desc" style="margin: 0; font-size: 1.1rem; line-height: 1.6; color: #e0e0ff; max-width: 500px; margin: 0 auto; transform-style: preserve-3d; backface-visibility: hidden; transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);">
          </p>
          <div id="landmark-info" style="::before { content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px; background: linear-gradient(45deg, #ff5fb7, #66e0ff, #a86bff); z-index: -1; border-radius: 17px; opacity: 0.7; filter: blur(5px); animation: gradient 8s ease infinite; background-size: 200% 200%; }"></div>
        </div>
      </div>
    </div>
    <!-- HERO -->
        <section class="hero smooth-hero">
        <div class="hero-inner">

          <h1 class="hero-title">
            The first <span class="gradient-txt">decentralized cloud</span>
            that feels instant.
          </h1>

          <p class="hero-sub">
            Store more with <strong>95% lossless compression</strong>. Collaborate with near-zero latency.  
            Built for speed, privacy, and the real world.
          </p>
          <p style="color: var(--accent4); margin-top: 8px; font-size: 1rem; opacity: .9;">
            Currently in <strong>Beta</strong> — early access available for @columbia.edu, @nyu.edu, and @cornell.edu.
          </p>

          <div class="hero-buttons">
            <a class="btn" href="#get-app">
              <i class="fas fa-download"></i> Download Now
            </a>
            <a class="btn ghost" href="#features">Learn More</a>
          </div>

        </div>
      </section>


    <!-- FEATURES -->
    <section id="features">
      <div class="container">
        <h2 class="section-title">Built for speed, privacy & scale</h2>
        <p class="section-sub">Our stack merges decentralized topology with algorithmic bandwidth magic for a cloud that it's just <em>like in real-life</em>.</p>
        <div class="grid features">
          <div class="card feature">
            <h3>Lossless storage efficiency</h3>
            <p>Store more with proprietary <strong>95% lossless</strong> compression while preserving every bit that matters.</p>
          </div>
          <div class="card feature">
            <h3>Instant bandwidth optimization</h3>
            <p>Smart routing and compression keep quality high of anything while usage stays low.</p>
          </div>
          <div class="card feature">
            <h3>Realtime collaboration</h3>
            <p>Docs, code, and whiteboards update with near‑zero delay — it’s like you’re sharing the same screen.</p>
          </div>
          <div class="card feature">
            <h3>High‑res calls & streaming</h3>
            <p>Crystal‑clear audio and video with automatic adaptation — no perfect network required.</p>
          </div>
          <div class="card feature">
            <h3>Decentralized by design</h3>
            <p>All devices work together as one powerful network — the more that join, the faster, stronger, and more private it becomes.</p>
          </div>
          <div class="card feature">
            <h3>Developer‑friendly Collab</h3>
            <p>Edit, build, and innovate together with unlimited teammates. Seamlessly, securely, and without delay.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- INSTANT SEARCH & ORGANIZATION -->
    <section id="search" style="padding:80px 0; background: linear-gradient(135deg, rgba(14,11,22,0.8), rgba(26,16,43,0.9));">
      <div class="container">
        <div style="text-align:center; margin-bottom:60px;" class="animate-on-scroll">
          <h2 class="section-title" style="animation: slideInLeft 0.8s ease-out;">Instant Search & Organization</h2>
          <p class="section-sub" style="animation: slideInLeft 0.8s ease-out 0.2s both;">With our advanced search algorithms, find and search millions of compressed files instantly — without the need to decompress. Edit, organize, and access everything in seconds, saving time and storage.</p>
        </div>
        <div class="grid" style="grid-template-columns:repeat(auto-fit, minmax(280px,1fr)); gap:30px;">
          <div class="card feature animate-on-scroll" style="animation: fadeInUp 0.8s ease-out 0.4s both; animation-play-state: running;">
            <div style="width:60px; height:60px; background:linear-gradient(135deg,var(--accent4),var(--accent1)); border-radius:12px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; font-size:24px; animation: pulseGlow 2s infinite;">
              <i class="fas fa-search" style="color:#fff; font-size:28px;"></i>
            </div>
            <h3 style="animation: fadeInUp 0.8s ease-out 0.6s both;">Lightning-Fast Search</h3>
            <p style="animation: fadeInUp 0.8s ease-out 0.8s both;">With our search algorithms, dive into compressed files instantly — no decompression needed. Find anything in seconds across your entire library.</p>
          </div>
          <div class="card feature animate-on-scroll" style="animation: fadeInUp 0.8s ease-out 0.5s both;">
            <div style="width:60px; height:60px; background:linear-gradient(135deg,var(--accent2),var(--accent3)); border-radius:12px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; font-size:24px; animation: pulseGlow 2s infinite 0.5s;">
              <i class="fas fa-folder" style="color:#fff; font-size:28px;"></i>
            </div>
            <h3 style="animation: fadeInUp 0.8s ease-out 0.7s both;">Smart Organization</h3>
            <p style="animation: fadeInUp 0.8s ease-out 0.9s both;">AI-driven categorization keeps your files organized automatically. Tags, folders, and previews update in real-time, even for compressed content.</p>
          </div>
          <div class="card feature animate-on-scroll" style="animation: fadeInUp 0.8s ease-out 0.6s both;">
            <div style="width:60px; height:60px; background:linear-gradient(135deg,var(--accent1),var(--accent4)); border-radius:12px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; font-size:24px; animation: pulseGlow 2s infinite 1s;">
              <i class="fas fa-edit" style="color:#fff; font-size:28px;"></i>
            </div>
            <h3 style="animation: fadeInUp 0.8s ease-out 0.8s both;">Edit Without Decompression</h3>
            <p style="animation: fadeInUp 0.8s ease-out 1s both;">Modify and search compressed files directly. Our tech lets you edit, annotate, and query without losing quality or time.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- TOOLS -->
    <section id="tools">
      <div class="container">
        <h2 class="section-title">Tools that feel magical</h2>
        <p class="section-sub">Everything you need — chat, calls, streaming, docs, code, and whiteboard — all where your files live. Instantly search, edit, and even work with your compressed files, all with sub-second response.</p>
        <div class="grid tools">
          <div class="card tool"><strong>Lightning chat/calls</strong><span>~5ms latency, like real life</span></div>
          <div class="card tool"><strong>Video calls</strong><span>High resolution on low bandwidth</span></div>
          <div class="card tool"><strong>Streaming</strong><span>High qualily playback that adapts to you</span></div>
          <div class="card tool"><strong>PDF tools</strong><span>Merge, split, annotate in the cloud</span></div>
          <div class="card tool"><strong>Docs & code</strong><span>Realtime editing with no friction</span></div>
          <div class="card tool"><strong>Whiteboard</strong><span>Draw, plan, design</span></div>
          <div class="card tool"><strong>Game launcher</strong><span>Ultra‑high FPS on any device <em>(coming soon)</em></span></div>
          <div class="card tool"><strong>Optimizers & simulators</strong><span>Hard problems, fast answers <em>(coming soon)</em></span></div>
        </div>
      </div>
    </section>

    <!-- GET THE APP -->
    <section id="get-app">
      <div class="container">
        <div class="form-wrap">
          <div class="card" style="padding:26px 24px">
            <h2 class="section-title">Get the App Now</h2>
            <p class="section-sub">Complete the form and we'll email you download instructions. Currently available for <strong>@columbia.edu, @nyu.edu, and @cornell.edu</strong> email addresses.</p>
            
            <div style="margin: 24px 0;">
              <h3 style="margin: 0 0 16px 0; color: var(--accent4);">Pricing Plans</h3>
              <div style="display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- Mobile-first single column, changes to 3 columns on larger screens -->
                <style>
                  @media (min-width: 768px) {
                    #pricing-plans-container { grid-template-columns: repeat(3, 1fr); }
                  }
                  @media (min-width: 480px) and (max-width: 767px) {
                    #pricing-plans-container { grid-template-columns: repeat(2, 1fr); }
                  }
                </style>
                <!-- Free Plan -->
                <div class="card" style="padding: 20px; background: linear-gradient(135deg, rgba(255,255,255,.02), rgba(255,255,255,.05)); height: 100%;">
                  <h3 style="margin: 0 0 10px 0; color: var(--muted);">Free</h3>
                  <div style="font-size: 1.8rem; font-weight: 900; margin-bottom: 15px;">$0<span style="font-size: 1rem; font-weight: normal; color: var(--muted);">/month</span></div>
                  <ul style="list-style: none; padding: 0; margin: 0 0 20px 0; display: grid; gap: 8px; color: #e9e7ff; font-size: 0.95rem;">
                    <li>• 15GB Storage (3GB compressed)</li>
                    <li>• 1 hour bandwidth optimization/day</li>
                    <li>• Basic cloud tools</li>
                    <li>• Standard support</li>
                  </ul>
                  <div style="font-size: 0.9rem; color: var(--accent4); font-weight: 500;">No credit card required</div>
                </div>

                <!-- Basic Plan -->
                <div class="card" style="padding: 20px; background: linear-gradient(135deg, rgba(168,107,255,.1), rgba(255,95,183,.1)); position: relative; border: 1px solid rgba(168,107,255,.2); height: 100%;">
                  <div style="position: absolute; top: 10px; right: 10px; background: var(--accent3); color: #000; font-size: 0.7rem; padding: 2px 8px; border-radius: 12px; font-weight: 600;">POPULAR</div>
                  <h3 style="margin: 0 0 10px 0; color: var(--accent3);">Basic</h3>
                  <div style="font-size: 1.8rem; font-weight: 900; margin-bottom: 15px;">$4.99<span style="font-size: 1rem; font-weight: normal; color: var(--muted);">/month</span></div>
                  <ul style="list-style: none; padding: 0; margin: 0 0 20px 0; display: grid; gap: 8px; color: #e9e7ff; font-size: 0.95rem;">
                    <li>• 100GB Storage (5GB compressed)</li>
                    <li>• 50GB bandwidth optimization</li>
                    <li>• Limited cloud tools access</li>
                    <li>• Priority support</li>
                  </ul>
                  <div style="font-size: 0.9rem; color: var(--accent3); font-weight: 500;">30-day free trial</div>
                </div>

                <!-- Pro Plan -->
                <div class="card" style="padding: 20px; background: linear-gradient(135deg, rgba(255,95,183,.1), rgba(102,224,255,.1)); position: relative; border: 1px solid rgba(102,224,255,.2); height: 100%;">
                  <div style="position: absolute; top: 10px; right: 10px; background: var(--accent4); color: #000; font-size: 0.7rem; padding: 2px 8px; border-radius: 12px; font-weight: 600;">BEST VALUE</div>
                  <h3 style="margin: 0 0 10px 0; color: var(--accent4);">Pro</h3>
                  <div style="font-size: 1.8rem; font-weight: 900; margin-bottom: 15px;">$9.99<span style="font-size: 1rem; font-weight: normal; color: var(--muted);">/month</span></div>
                  <ul style="list-style: none; padding: 0; margin: 0 0 20px 0; display: grid; gap: 8px; color: #e9e7ff; font-size: 0.95rem;">
                    <li>• 1TB Storage (<30GB compressed)</li>
                    <li>• 200GB bandwidth optimization</li>
                    <li>• Full cloud tools access</li>
                    <li>• 24/7 priority support</li>
                    <li>• AI trainer & optimization tools</li>
                    <li>• Exclusive early access to new features (best for developers and scientists)</li>
                  </ul>
                  <div style="font-size: 0.9rem; color: var(--accent4); font-weight: 500;">30-day free trial</div>
                </div>
              </div>
            </div>
          </div>
          
          <form id="appForm" class="card" novalidate style="padding: 24px; margin-top: 30px;">
            <h3 style="margin: 0 0 20px 0; font-size: 1.4rem;">Download Request</h3>
            <input type="text" name="company" autocomplete="off" tabindex="-1" style="position:absolute;left:-9999px;opacity:0" aria-hidden="true" required>
            
            <div class="row" style="display: flex; flex-direction: column; gap: 20px;">
              <style>
                @media (min-width: 768px) {
                  .row { flex-direction: row !important; }
                  .row > div { flex: 1; }
                }
              </style>
              <div>
                <label for="name">Full Name</label>
                <input class="input" type="text" id="name" name="name" placeholder="Your full name" required>
              </div>
              <div>
                <label for="email">Email (@columbia.edu, @nyu.edu, @cornell.edu)</label>
                <input class="input" type="email" id="email" name="email" placeholder="your@columbia.edu" pattern="[^@\s]+@(columbia\.edu|nyu\.edu|cornell\.edu)$" title="Please use a columbia.edu, nyu.edu, or cornell.edu email address" required>
              </div>
            </div>
            
            <label for="devices">Number of Devices</label>
            <select id="devices" name="devices" class="input" required>
              <option value="" disabled selected>Select number of devices</option>
              <option value="1">1 Device</option>
              <option value="2">2 Devices</option>
              <option value="3">3 Devices</option>
              <option value="4">4 Devices</option>
              <option value="5">5+ Devices (contact us)</option>
            </select>
            
            <label style="margin-top: 15px;">Platforms (select all that apply)</label>
            <div style="display: grid; gap: 10px; margin: 10px 0 20px;" id="platforms-container">
              <p style="margin: 0 0 5px 0; color: var(--muted); font-size: 0.9rem;">Select at least one platform <span style="color: #ff4d6d">*</span></p>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.03);">
                  <input type="checkbox" name="platform" value="ios" required>
                  <span>iOS</span>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.03);">
                  <input type="checkbox" name="platform" value="android">
                  <span>Android</span>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.03);">
                  <input type="checkbox" name="platform" value="windows">
                  <span>Windows</span>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.03);">
                  <input type="checkbox" name="platform" value="macos">
                  <span>macOS</span>
                </label>
              </div>
            </div>
            
            <label for="plan">Select Plan</label>
            <select id="plan" name="plan" class="input" required>
              <option value="" disabled selected>Choose your plan</option>
              <option value="free">Free - $0/month (15GB storage, 3GB compressed, 1 hour bandwidth optimization)</option>
              <option value="basic">Basic - $4.99/month (100GB storage, 5GB compressed, 50GB bandwidth, Limited cloud tools)</option>
              <option value="pro">Pro - $9.99/month (1TB storage, <30GB compressed, 200GB bandwidth, Full access + future tools)</option>
            </select>
            <p style="font-size: 0.85rem; color: var(--muted); margin: 5px 0 0 0;">All paid plans include a 30-day free trial. Cancel anytime.</p>
            
            <label class="terms" style="margin: 20px 0 10px;">
              <input type="checkbox" id="terms" required>
              <span>I agree to receive the <a class="gradient-txt">Terms of Service</a> and <a class="gradient-txt">Privacy Policy</a></span>
            </label>
            
            <button class="btn" type="submit" style="width: 100%; margin: 10px 0 15px; padding: 14px;" id="submitBtn">
              <i class="fas fa-paper-plane" style="margin-right: 8px;"></i> Get Download Link
            </button>
            
            <div class="success" id="okMsg" style="display: none; padding: 12px; background: rgba(177, 245, 196, 0.1); border-radius: 8px; border-left: 3px solid var(--accent4); margin: 10px 0;"></div>
            <div class="error" id="errMsg" style="display: none; padding: 12px; background: rgba(255, 178, 194, 0.1); border-radius: 8px; border-left: 3px solid #ff4d6d; margin: 10px 0; color: #ff4d6d; font-weight: 500;"></div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
              <p style="margin: 0 0 10px 0; color: var(--muted);">Don't have an eligible email address?</p>
              <button type="button" class="btn ghost" style="width: 100%;" onclick="document.getElementById('notify-form').style.display='block';this.style.display='none';">
                Notify me when available
              </button>
            </div>
            
            <div id="notify-form" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
              <p style="margin: 0 0 15px 0; color: var(--muted);">Enter your email to be notified when SP Cloud is available for your domain:</p>
              <div style="display: flex; gap: 10px;">
                <input type="email" id="notify-email" class="input" placeholder="your@email.com" style="flex: 1;">
                <button type="button" class="btn" onclick="alert('Thanks! We\'ll notify you when SP Cloud is available for your domain.');">Notify Me</button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </section>

    <!-- LEARN / IMAGE STRIP -->
    <!-- <section id="learn">
      <div class="container card" style="padding:18px">
        <img src="logo.png" alt="SP Cloud brand" style="width:100%;height:auto;border-radius:16px;opacity:.95"/>
      </div>
    </section> -->

    <!-- FOOTER -->
    <footer>
      <div class="container foot">
        <div class="logo-row">
          <div class="logo"><img src="logo.png" alt="SP logo"/></div>
          <div>&copy; 2025 SP Cloud Tech Inc. All rights reserved.</div>
        </div>
        <!-- <div style="display:flex;gap:16px">
          <a class="gradient-txt" href="#">Privacy</a>
          <a class="gradient-txt" href="#">Terms</a>
          <a class="gradient-txt" href="#preorder">Pre‑register</a>
        </div> -->
      </div>
    </footer>
    </div>

    <!-- <script src="https://kit.fontawesome.com/your-code.js" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <script type="text/javascript">
      (function() {
        emailjs.init("6QCmp2AnjIvZX_kx2"); // Replace with your EmailJS public key
      })();
    </script>
    <script type="text/javascript">
    emailjs.init('6QCmp2AnjIvZX_kx2')
  </script>

    <script>
      // Form submission handler with EmailJS integration

      
      document.getElementById('appForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Get form elements
        const form = e.target;
        const name = form.querySelector('#name').value.trim();
        const email = form.querySelector('#email').value.trim();
        const devices = form.querySelector('#devices').value;
        const plan = form.querySelector('#plan').value;
        const platforms = Array.from(form.querySelectorAll('input[name="platform"]:checked')).map(cb => cb.value);
        const termsAccepted = form.querySelector('#terms').checked;
        
        // Get message elements
        const successMsg = document.getElementById('okMsg');
        const errorMsg = document.getElementById('errMsg');
        const submitBtn = document.getElementById('submitBtn');
        const originalBtnText = submitBtn.innerHTML;
        
        // Hide previous messages and show loading state
        successMsg.style.display = 'none';
        errorMsg.style.display = 'none';
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...';
        
        // Validate all required fields
        const errors = [];
        
        if (!name) errors.push('Full Name');
        if (!email) errors.push('Email');
        if (!devices) errors.push('Number of Devices');
        if (platforms.length === 0) errors.push('At least one Platform');
        if (!plan) errors.push('Plan');
        if (!termsAccepted) errors.push('Terms & Conditions');
        
        // If there are validation errors
        if (errors.length > 0) {
          errorMsg.innerHTML = `Please fill in all required fields: ${errors.join(', ')}`;
          errorMsg.style.display = 'block';
          submitBtn.disabled = false;
          submitBtn.innerHTML = originalBtnText;
          
          // Scroll to the first error
          const firstError = document.querySelector('input:invalid, select:invalid, [required]:not(:checked)');
          if (firstError) {
            firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
            firstError.focus();
          }
          return;
        }
        
        // Validate email format
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          errorMsg.innerHTML = 'Please enter a valid email address';
          errorMsg.style.display = 'block';
          submitBtn.disabled = false;
          submitBtn.innerHTML = originalBtnText;
          document.getElementById('email').focus();
          return;
        }
        
        // Prepare email template parameters
        const templateParams = {
          from_name: name,
          from_email: email,
          to_email: email,
          devices: devices,
          plan: plan,
          platforms: platforms.join(', '),
          is_eligible: (email.endsWith('@columbia.edu') || email.endsWith('@nyu.edu') || email.endsWith('@cornell.edu')) ? 'Yes' : 'No'
        };
        
        // Send email using EmailJS
        emailjs.send('default_service', 'template_iq1b5eh', templateParams)
          .then(function(response) {
            console.log('SUCCESS!', response.status, response.text);
            
            // Show success message based on email domain
            if (email.endsWith('@columbia.edu') || email.endsWith('@nyu.edu') || email.endsWith('@cornell.edu')) {
              successMsg.innerHTML = 'Check your email for download instructions!';
            } else {
              successMsg.innerHTML = 'Thank you for your interest! We\'ll notify you when SP Cloud is available for your domain.';
            }
            successMsg.style.display = 'block';
            
            // Reset form
            form.reset();
            
            // Scroll to success message
            successMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, function(error) {
            console.error('FAILED...', error);
            
            // Show success message to user even if email fails (as per requirement)
            if (email.endsWith('@columbia.edu') || email.endsWith('@nyu.edu') || email.endsWith('@cornell.edu')) {
              successMsg.innerHTML = 'Thank you! Your request has been received. Check your email for download instructions soon.';
            } else {
              successMsg.innerHTML = 'Thank you for your interest! We\'ll notify you when SP Cloud is available for your domain.';
            }
            successMsg.style.display = 'block';
            
            // Also log the error in the console
            errorMsg.innerHTML = 'Note: There was an issue sending the email, but your request has been received.';
            errorMsg.style.display = 'block';
            
            // Reset form
            form.reset();
            
            // Scroll to messages
            successMsg.scrollIntoView({ behavior: 'smooth', block: 'center' });
          })
          .finally(() => {
            // Re-enable the submit button
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnText;
          });
      });

      // Smooth anchor scroll
      document.querySelectorAll('a[href^="#"]').forEach(a=>{
        a.addEventListener('click', e=>{
          const id = a.getAttribute('href');
          if(id.length>1){ e.preventDefault(); document.querySelector(id).scrollIntoView({behavior:'smooth'}); }
        })
      });

      // Add scroll animations
      const observerOptions = { threshold: 0.1 };
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('in-view');
          }
        });
      }, observerOptions);
      document.querySelectorAll('.animate-on-scroll').forEach(el => observer.observe(el));
      observer.observe(document.querySelector(".hero"));
      observer.observe(document.querySelector(".smooth-hero"));



      // Simple form validation + EmailJS submit
      // const form = document.getElementById('preorderForm');
      // form.addEventListener('submit', async (e)=>{
      //   e.preventDefault();
      //   const ok = document.getElementById('okMsg');
      //   const err = document.getElementById('errMsg');
      //   ok.style.display = 'none'; err.style.display = 'none';

      //   // Basic validation
      //   if(form.company.value){ err.style.display='block'; return } // honeypot triggered
      //   if(!form.name.value.trim()) { err.style.display='block'; return }
      //   if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(form.email.value)) { err.style.display='block'; return }
      //   if(!form.ref.value) { err.style.display='block'; return }
      //   if(!document.getElementById('terms').checked) { err.style.display='block'; return }

      //   try {
      //     // Send email using EmailJS sendForm (simpler, uses form data directly)
      //     await emailjs.sendForm('service_77zcepd', 'template_iq1b5eh', form);
      //     form.reset();
      //     ok.style.display='block';
      //   } catch(ex){
      //     console.log('EmailJS error:', ex);
      //     err.style.display='block';
      //   }
      // });
      // Mobile menu toggle functions
      function toggleMobileMenu() {
        const mobileMenu = document.getElementById('mobileMenu');
        const hamburger = document.querySelector('.hamburger');
        console.log('Toggle menu called'); // Debug log
        mobileMenu.classList.toggle('active');
        hamburger.classList.toggle('active');
      }
      function closeMobileMenu() {
        const mobileMenu = document.getElementById('mobileMenu');
        const hamburger = document.querySelector('.hamburger');
        mobileMenu.classList.remove('active');
        hamburger.classList.remove('active');
      }
      // Mobile menu functions
      function toggleMobileMenu() {
        const menu = document.getElementById('mobileMenu');
        const hamburger = document.querySelector('.hamburger');
        menu.classList.toggle('active');
        hamburger.classList.toggle('active');
        document.body.style.overflow = menu.classList.contains('active') ? 'hidden' : '';
      }
      
      function closeMobileMenu() {
        const menu = document.getElementById('mobileMenu');
        const hamburger = document.querySelector('.hamburger');
        menu.classList.remove('active');
        hamburger.classList.remove('active');
        document.body.style.overflow = '';
      }
      
      // Add event listeners after DOM is loaded
      document.addEventListener('DOMContentLoaded', function() {
        const hamburger = document.querySelector('.hamburger');
        if (hamburger) {
          hamburger.addEventListener('click', toggleMobileMenu);
        }
        
        // Add event listeners for mobile menu links to close menu on click
        document.querySelectorAll('.mobile-menu a').forEach(link => {
          link.addEventListener('click', closeMobileMenu);
        });
        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
          const mobileMenu = document.getElementById('mobileMenu');
          const hamburger = document.querySelector('.hamburger');
          const isClickInsideMenu = mobileMenu.contains(event.target);
          const isClickOnHamburger = hamburger.contains(event.target);
          if (!isClickInsideMenu && !isClickOnHamburger && mobileMenu.classList.contains('active')) {
            closeMobileMenu();
          }
        });
      });

      // Three.js Scene Setup
      let scene, camera, renderer, controls;
      let objects = [];
      let currentLandmark = 0;
      let currentModel = null;
      let clock = new THREE.Clock();
      let mixer = null;
      let isFirstLandmark = true; // Flag for first landmark transition
      let sceneReady = false;
      let quoteIntroReady = false;
      let introLaunched = false;
      let firstTransitionDone = false;
      let quoteFloatTween = null;
      let firstModelPrepared = false;
      let firstModelVisible = false;

      // Preload first landmark model
      let preloadedModel = null;
      
      // 3D Models and Animations
      const models = {
        aetherGateway: {
          create: () => {
            const group = new THREE.Group();
            
            // Core prism
            const prismMaterial = new THREE.MeshPhysicalMaterial({
              color: 0xffbaf9,
              emissive: 0x5c36ff,
              emissiveIntensity: 0.8,
              roughness: 0.25,
              metalness: 0.5,
              transparent: true,
              opacity: 0.85,
              clearcoat: 1,
              clearcoatRoughness: 0.1
            });
            const prism = new THREE.Mesh(
              new THREE.IcosahedronGeometry(1, 2),
              prismMaterial
            );
            group.add(prism);
            
            // Halo rings
            const halos = [];
            for (let i = 0; i < 3; i++) {
              const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0x66e0ff,
                transparent: true,
                opacity: 0.35 + i * 0.2,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
              });
              const halo = new THREE.Mesh(
                new THREE.TorusGeometry(1.2 + i * 0.35, 0.04 + i * 0.01, 32, 128),
                haloMaterial
              );
              halo.rotation.x = Math.PI / 2;
              halo.userData = {
                speed: 0.4 + i * 0.1,
                direction: i % 2 === 0 ? 1 : -1
              };
              group.add(halo);
              halos.push(halo);
            }
            
            // Crystal shards
            const shards = [];
            for (let i = 0; i < 12; i++) {
              const shard = new THREE.Mesh(
                new THREE.ConeGeometry(0.05, 0.4, 4),
                new THREE.MeshPhongMaterial({
                  color: 0xffffff,
                  emissive: 0x66e0ff,
                  emissiveIntensity: 0.5,
                  shininess: 90
                })
              );
              const radius = 1.6 + Math.random() * 0.8;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.random() * Math.PI;
              shard.position.set(
                Math.sin(phi) * Math.cos(theta) * radius,
                Math.cos(phi) * radius * 0.5,
                Math.sin(phi) * Math.sin(theta) * radius
              );
              shard.userData = {
                offset: Math.random() * Math.PI * 2,
                radius,
                drift: 0.2 + Math.random() * 0.4
              };
              group.add(shard);
              shards.push(shard);
            }
            
            // Particle aura
            const particleCount = 140;
            const positions = new Float32Array(particleCount * 3);
            const basePositions = new Float32Array(particleCount * 3);
            const offsets = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
              const radius = 2.2 + Math.random() * 1.5;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const x = radius * Math.sin(phi) * Math.cos(theta);
              const y = radius * Math.sin(phi) * Math.sin(theta);
              const z = radius * Math.cos(phi);
              positions[i * 3] = x;
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = z;
              basePositions[i * 3] = x;
              basePositions[i * 3 + 1] = y;
              basePositions[i * 3 + 2] = z;
              offsets[i] = Math.random() * Math.PI * 2;
            }
            
            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({
              color: 0xffffff,
              size: 0.06,
              transparent: true,
              opacity: 0.55,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            particles.userData = { basePositions, offsets };
            group.add(particles);
            
            // Store the original scale of the group
            const originalScale = 2.8; // This should match the scale in landmarks
            
            return {
              model: group,
              animate: (time) => {
                // Only animate the internal components, not the group itself
                prism.rotation.x = time * 0.4;
                prism.rotation.y = time * 0.6;
                prism.material.emissiveIntensity = 0.8 + Math.sin(time * 2) * 0.2;
                
                // Animate halos with scaling, but keep it subtle
                halos.forEach((halo, index) => {
                  halo.rotation.z = time * halo.userData.speed * halo.userData.direction * 0.5;
                  // Keep the scale animation but make it more subtle
                  const scale = 1 + Math.sin(time * 0.8 + index) * 0.04;
                  halo.scale.set(scale, scale, 1); // Only scale X and Y, not Z
                });
                
                // Animate shards with position only, no scaling
                shards.forEach((shard, i) => {
                  const t = time * 0.6 + shard.userData.offset;
                  shard.position.x = basePositions[i * 3] * (1 + Math.sin(t) * 0.1 * shard.userData.drift);
                  shard.position.y = basePositions[i * 3 + 1] * (1 + Math.cos(t * 0.7) * 0.1 * shard.userData.drift);
                  shard.position.z = basePositions[i * 3 + 2] * (1 + Math.sin(t * 0.5) * 0.1 * shard.userData.drift);
                  shard.rotation.x = time * 0.2;
                  shard.rotation.y = time * 0.3;
                  // Ensure shards maintain their scale
                  shard.scale.set(1, 1, 1);
                });
                
                // Animate particles with position only
                const particlePositions = particles.geometry.attributes.position;
                const basePos = particles.userData.basePositions;
                const offsets = particles.userData.offsets;
                
                for (let i = 0; i < particlePositions.count; i++) {
                  const t = time * 0.5 + offsets[i];
                  const drift = 0.05 + (i % 3) * 0.03;
                  particlePositions.setX(i, basePos[i * 3] * (1 + Math.sin(t * 0.8) * 0.1 * drift));
                  particlePositions.setY(i, basePos[i * 3 + 1] * (1 + Math.cos(t * 0.7) * 0.1 * drift));
                  particlePositions.setZ(i, basePos[i * 3 + 2] * (1 + Math.sin(t * 0.9) * 0.1 * drift));
                }
                
                particlePositions.needsUpdate = true;
                
                // Ensure the main group maintains its scale
                if (group.scale.x !== originalScale) {
                  group.scale.set(originalScale, originalScale, originalScale);
                }
              }
            };
          }
        },
        compression: {
            create: () => {
              const group = new THREE.Group();

              // -------------------------
              // 1) CREATE DATA CUBE CORE
              // -------------------------
              const cubeGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
              const cubeMaterial = new THREE.MeshPhongMaterial({
                color: 0x66e0ff,
                emissive: 0x0044ff,
                emissiveIntensity: 0.7,
                shininess: 120,
                transparent: true,
                opacity: 0.95
              });
              const coreCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
              group.add(coreCube);

              // -------------------------
              // 2) SMALL DATA BLOCKS
              // -------------------------
              const blocks = [];
              const blockGeo = new THREE.BoxGeometry(0.18, 0.18, 0.18);
              const blockMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x2288ff,
                emissiveIntensity: 0.4
              });

              for (let i = 0; i < 50; i++) {
                const b = new THREE.Mesh(blockGeo, blockMat.clone());

                // Arrange blocks in a cube-shell instead of random cloud
                b.position.set(
                  (Math.random() - 0.5) * 3,
                  (Math.random() - 0.5) * 3,
                  (Math.random() - 0.5) * 3
                );

                b.userData = {
                  offset: b.position.clone(),
                  speed: 0.6 + Math.random() * 1.2
                };

                blocks.push(b);
                group.add(b);
              }

              // -------------------------
              // 3) COMPRESSION PLATES
              // -------------------------
              const plateGeo = new THREE.BoxGeometry(2.5, 2.5, 0.1);
              const plateMat = new THREE.MeshPhongMaterial({
                color: 0x111111,
                emissive: 0x003366,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.4
              });

              const leftPlate = new THREE.Mesh(plateGeo, plateMat);
              leftPlate.position.x = -4;
              group.add(leftPlate);

              const rightPlate = new THREE.Mesh(plateGeo, plateMat);
              rightPlate.position.x = 4;
              group.add(rightPlate);

              // -------------------------
              // 4) REVEAL ANIMATION
              // -------------------------
              group.scale.set(0.2, 0.2, 0.2);
              group.rotation.set(0, Math.PI, 0);
              group.position.y -= 0.4;

              gsap.to(group.scale, {
                x: 1, y: 1, z: 1,
                duration: 1.2,
                ease: "back.out(1.8)"
              });

              gsap.to(group.rotation, {
                y: 0,
                duration: 1.4,
                ease: "power3.out"
              });

              // Plates slide inward
              gsap.to(leftPlate.position, {
                x: -1.6,
                duration: 1.2,
                ease: "power3.out",
                delay: 0.4
              });
              gsap.to(rightPlate.position, {
                x: 1.6,
                duration: 1.2,
                ease: "power3.out",
                delay: 0.4
              });

              // -------------------------
              // 5) RETURN MODEL + ANIMATION LOOP
              // -------------------------
              return {
                model: group,
                animate: (t) => {
                  group.rotation.y += 0.002;

                  // Float blocks slightly (subtle)
                  blocks.forEach(b => {
                    b.position.x = b.userData.offset.x + Math.sin(t * b.userData.speed) * 0.05;
                    b.position.y = b.userData.offset.y + Math.cos(t * b.userData.speed) * 0.05;
                  });

                  // Pulse cube
                  const pulse = 0.96 + Math.sin(t * 2) * 0.06;
                  coreCube.scale.set(pulse, pulse, pulse);
                  cubeMaterial.emissiveIntensity = 0.7 + Math.sin(t * 2) * 0.3;
                }
              };
            }
          },
        bandwidth: {
          create: () => {
            const group = new THREE.Group();
            
            // Create a wave form
            const points = [];
            const geometry = new THREE.BufferGeometry();
            
            for (let i = 0; i < 20; i++) {
              points.push(new THREE.Vector3(
                (i - 10) * 0.5,
                Math.sin(i * 0.5) * 0.5,
                0
              ));
            }
            
            geometry.setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
              color: 0x66e0ff,
              linewidth: 3
            });
            
            const line = new THREE.Line(geometry, material);
            group.add(line);
            
            // Add moving particles
            const particles = [];
            const particleCount = 10;
            
            for (let i = 0; i < particleCount; i++) {
              const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x66e0ff })
              );
              
              particle.position.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 2,
                0
              );
              
              particle.userData = {
                speed: 0.5 + Math.random() * 0.5,
                offset: Math.random() * Math.PI * 2
              };
              
              group.add(particle);
              particles.push(particle);
            }
            
            return {
              model: group,
              animate: (time) => {
                // Animate wave
                const positions = line.geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                  positions.setY(
                    i,
                    Math.sin(i * 0.5 + time * 2) * 0.5
                  );
                }
                positions.needsUpdate = true;
                
                // Animate particles
                particles.forEach((particle, i) => {
                  particle.position.x += particle.userData.speed * 0.05;
                  particle.position.y = Math.sin(time * 2 + i) * 0.5;
                  
                  if (particle.position.x > 5) {
                    particle.position.x = -5;
                  }
                });
                
                group.rotation.y = time * 0.1;
              }
            };
          }
        },
        latency: {
          create: () => {
            const group = new THREE.Group();
            
            // Create a speed gauge
            const createGauge = (radius, color) => {
              const segments = 32;
              const material = new THREE.MeshBasicMaterial({
                color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
              });
              
              const geometry = new THREE.RingGeometry(
                radius - 0.2,
                radius,
                segments,
                1,
                0,
                Math.PI
              );
              
              const arc = new THREE.Mesh(geometry, material);
              arc.rotation.x = Math.PI / 2;
              arc.rotation.z = Math.PI;
              
              return arc;
            };
            
            // Add gauge rings
            const outerGauge = createGauge(2, 0x66e0ff);
            const middleGauge = createGauge(1.6, 0x66aaff);
            const innerGauge = createGauge(1.2, 0x6666ff);
            
            group.add(outerGauge, middleGauge, innerGauge);
            
            // Add needle
            const needle = new THREE.Mesh(
              new THREE.BoxGeometry(0.1, 1.5, 0.1),
              new THREE.MeshBasicMaterial({ color: 0xff5555 })
            );
            needle.position.y = 0.75;
            group.add(needle);
            
            return {
              model: group,
              animate: (time) => {
                // Make needles move to show low latency
                needle.rotation.z = Math.sin(time * 2) * 0.1 - Math.PI/2;
                
                // Pulsing effect on gauges
                const pulse = Math.sin(time * 2) * 0.1 + 0.9;
                outerGauge.scale.set(pulse, pulse, 1);
                middleGauge.scale.set(pulse * 0.9, pulse * 0.9, 1);
                innerGauge.scale.set(pulse * 0.8, pulse * 0.8, 1);
                
                group.rotation.y = time * 0.2;
              }
            };
          }
        },
        collaboration: {
          create: () => {
            const group = new THREE.Group();
            
            // Create multiple user avatars
            const colors = [0x66aaff, 0xff66aa, 0x66ffaa, 0xffcc66];
            const users = [];
            
            colors.forEach((color, i) => {
              const angle = (i / colors.length) * Math.PI * 2;
              const radius = 1.5;
              
              // User icon
              const geometry = new THREE.CircleGeometry(0.5, 32);
              const material = new THREE.MeshBasicMaterial({
                color,
                side: THREE.DoubleSide
              });
              
              const user = new THREE.Mesh(geometry, material);
              user.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle) * radius,
                0
              );
              
              // Connection line to center
              const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(
                  Math.cos(angle) * radius,
                  Math.sin(angle) * radius,
                  0
                )
              ]);
              
              const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
              });
              
              const line = new THREE.Line(lineGeometry, lineMaterial);
              
              group.add(user, line);
              users.push({
                mesh: user,
                line,
                angle,
                radius,
                speed: 0.5 + Math.random()
              });
            });
            
            return {
              model: group,
              users,
              animate: (time) => {
                // Animate users moving around
                users.forEach((user, i) => {
                  const angle = user.angle + time * user.speed * 0.1;
                  const radius = user.radius + Math.sin(time * user.speed) * 0.2;
                  
                  user.mesh.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                  );
                  
                  // Update connection line
                  const positions = user.line.geometry.attributes.position;
                  positions.setXYZ(1, 
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                  );
                  positions.needsUpdate = true;
                  
                  // Pulsing effect
                  user.mesh.scale.setScalar(1 + Math.sin(time * user.speed * 2) * 0.1);
                });
                
                group.rotation.y = time * 0.05;
              }
            };
          }
        },
        tools: {
          create: () => {
            const group = new THREE.Group();
            
            // Create floating tools
            const tools = [
              { type: 'file', color: 0x66aaff, size: 0.5, pos: [0, 0, 0] },
              { type: 'edit', color: 0xffaa66, size: 0.4, pos: [1, 0.5, 0] },
              { type: 'share', color: 0x66ffaa, size: 0.4, pos: [-1, -0.5, 0] },
              { type: 'convert', color: 0xff66aa, size: 0.4, pos: [0.7, -0.7, 0] },
              { type: 'compress', color: 0xaa66ff, size: 0.4, pos: [-0.7, 0.7, 0] }
            ];
            
            tools.forEach((tool, i) => {
              let geometry;
              
              switch(tool.type) {
                case 'file':
                  geometry = new THREE.BoxGeometry(0.8, 1, 0.1);
                  break;
                case 'edit':
                  geometry = new THREE.ConeGeometry(0.3, 0.6, 4);
                  break;
                case 'share':
                  geometry = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
                  break;
                case 'convert':
                  geometry = new THREE.OctahedronGeometry(0.3, 0);
                  break;
                case 'compress':
                  geometry = new THREE.DodecahedronGeometry(0.3, 0);
                  break;
              }
              
              const material = new THREE.MeshPhongMaterial({
                color: tool.color,
                shininess: 100,
                transparent: true,
                opacity: 0.9
              });
              
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.set(tool.pos[0], tool.pos[1], tool.pos[2]);
              mesh.userData = {
                speed: 0.5 + Math.random(),
                offset: Math.random() * Math.PI * 2
              };
              
              group.add(mesh);
            });
            
            return {
              model: group,
              animate: (time) => {
                group.children.forEach((child, i) => {
                  // Floating animation
                  child.position.y += Math.sin(time * child.userData.speed + i) * 0.005;
                  
                  // Rotation
                  child.rotation.x = time * 0.2 * child.userData.speed;
                  child.rotation.y = time * 0.3 * child.userData.speed;
                  
                  // Pulsing scale
                  const scale = 1 + Math.sin(time * child.userData.speed + i) * 0.1;
                  child.scale.set(scale, scale, scale);
                });
                
                group.rotation.y = time * 0.1;
              }
            };
          }
        },
        encryption: {
          create: () => {
            const group = new THREE.Group();
            
            // Create a sphere for the core
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhongMaterial({
              color: 0x66aaff,
              transparent: true,
              opacity: 0.3,
              wireframe: true
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            
            // Add encryption layers
            const layers = [];
            const layerCount = 3;
            
            for (let i = 0; i < layerCount; i++) {
              const layerGeometry = new THREE.IcosahedronGeometry(1.5 + i * 0.5, 1);
              const layerMaterial = new THREE.MeshBasicMaterial({
                color: 0x66aaff,
                wireframe: true,
                transparent: true,
                opacity: 0.3
              });
              
              const layer = new THREE.Mesh(layerGeometry, layerMaterial);
              layer.userData = {
                speed: 0.2 + i * 0.1,
                direction: Math.random() > 0.5 ? 1 : -1
              };
              
              group.add(layer);
              layers.push(layer);
            }
            
            // Add floating lock icon
            const lockGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.2);
            const lockMaterial = new THREE.MeshPhongMaterial({
              color: 0x66e0ff,
              shininess: 100
            });
            
            const lock = new THREE.Mesh(lockGeometry, lockMaterial);
            lock.position.y = 1.5;
            group.add(lock);
            
            return {
              model: group,
              layers,
              lock,
              animate: (time) => {
                // Animate layers
                layers.forEach((layer, i) => {
                  layer.rotation.x = time * 0.1 * layer.userData.speed * layer.userData.direction;
                  layer.rotation.y = time * 0.15 * layer.userData.speed * (i % 2 === 0 ? 1 : -1);
                });
                
                // Animate lock
                lock.position.y = 1.5 + Math.sin(time) * 0.1;
                lock.rotation.y = time * 0.5;
                
                // Pulsing sphere
                const pulse = 1 + Math.sin(time * 2) * 0.05;
                sphere.scale.set(pulse, pulse, pulse);
                
                group.rotation.y = time * 0.05;
              }
            };
          }
        },
        cloud: {
          create: () => {
            const geometry = new THREE.IcosahedronGeometry(2, 3);
            const material = new THREE.MeshPhongMaterial({
              color: 0x66aaff,
              transparent: true,
              opacity: 0.8,
              shininess: 100,
              emissive: 0x112244,
              specular: 0xffffff
            });
            const cloud = new THREE.Mesh(geometry, material);
            cloud.scale.set(0.1, 0.1, 0.1);
            return { model: cloud, animate: (time) => {
              cloud.rotation.y = time * 0.2;
              cloud.scale.setScalar(0.1 + Math.sin(time * 2) * 0.01);
            }};
          }
        },
        network: {
          create: () => {
            const group = new THREE.Group();
            const nodes = [];
            const lines = [];
            
            // Create nodes
            for (let i = 0; i < 5; i++) {
              const geometry = new THREE.SphereGeometry(0.2, 16, 16);
              const material = new THREE.MeshBasicMaterial({ color: 0x66e0ff });
              const sphere = new THREE.Mesh(geometry, material);
              
              // Position in a sphere
              const radius = 1.5;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              sphere.position.set(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
              );
              
              nodes.push({
                mesh: sphere,
                speed: 0.1 + Math.random() * 0.2,
                startPos: sphere.position.clone()
              });
              group.add(sphere);
            }
            
            // Create connections
            for (let i = 0; i < nodes.length; i++) {
              for (let j = i + 1; j < nodes.length; j++) {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                  nodes[i].mesh.position.clone(),
                  nodes[j].mesh.position.clone()
                ]);
                const material = new THREE.LineBasicMaterial({
                  color: 0x66e0ff,
                  transparent: true,
                  opacity: 0.5
                });
                const line = new THREE.Line(geometry, material);
                lines.push({ line, node1: i, node2: j });
                group.add(line);
              }
            }
            
            return {
              model: group,
              nodes: nodes,
              lines: lines,
              animate: (time) => {
                // Animate nodes
                nodes.forEach((node, i) => {
                  node.mesh.position.x = node.startPos.x + Math.sin(time * node.speed) * 0.3;
                  node.mesh.position.y = node.startPos.y + Math.cos(time * node.speed * 0.7) * 0.3;
                  node.mesh.position.z = node.startPos.z + Math.sin(time * node.speed * 0.5) * 0.3;
                });
                
                // Update lines
                lines.forEach(lineData => {
                  const positions = lineData.line.geometry.attributes.position;
                  positions.setXYZ(0, 
                    nodes[lineData.node1].mesh.position.x,
                    nodes[lineData.node1].mesh.position.y,
                    nodes[lineData.node1].mesh.position.z
                  );
                  positions.setXYZ(1,
                    nodes[lineData.node2].mesh.position.x,
                    nodes[lineData.node2].mesh.position.y,
                    nodes[lineData.node2].mesh.position.z
                  );
                  positions.needsUpdate = true;
                });
                
                group.rotation.y = time * 0.1;
              }
            };
          }
        },
        storage: {
          create: () => {
            const group = new THREE.Group();
            
            // Create storage cubes
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({
              color: 0xaa66ff,
              transparent: true,
              opacity: 0.8,
              shininess: 100,
              emissive: 0x221144,
              specular: 0xffffff
            });
            
            const cubes = [];
            const count = 8;
            const radius = 1.5;
            
            for (let i = 0; i < count; i++) {
              const cube = new THREE.Mesh(geometry, material.clone());
              const angle = (i / count) * Math.PI * 2;
              cube.position.x = Math.cos(angle) * radius;
              cube.position.z = Math.sin(angle) * radius;
              cube.scale.set(0.5, 0.1 + Math.random() * 0.5, 0.5);
              cube.userData = { angle: angle, speed: 0.1 + Math.random() * 0.2 };
              group.add(cube);
              cubes.push(cube);
            }
            
            return {
              model: group,
              cubes: cubes,
              animate: (time) => {
                cubes.forEach((cube, i) => {
                  const angle = cube.userData.angle + time * cube.userData.speed * 0.5;
                  cube.position.x = Math.cos(angle) * radius;
                  cube.position.z = Math.sin(angle) * radius;
                  cube.rotation.y = time * 0.5;
                  
                  // Pulsing effect
                  const scale = 0.8 + Math.sin(time * 2 + i) * 0.2;
                  cube.scale.set(scale, cube.scale.y, scale);
                });
                group.rotation.y = time * 0.1;
              }
            };
          }
        },
        globe: {
          create: () => {
            const group = new THREE.Group();
            
            // Create globe
            const geometry = new THREE.SphereGeometry(1.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({
              color: 0x66aaff,
              transparent: true,
              opacity: 0.3,
              wireframe: true
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            
            // Add points for network nodes
            const points = [];
            const pointCount = 20;
            for (let i = 0; i < pointCount; i++) {
              const phi = Math.acos(-1 + (2 * i) / pointCount);
              const theta = Math.sqrt(pointCount * Math.PI) * phi;
              
              const point = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x66e0ff })
              );
              
              point.position.setFromSphericalCoords(1.6, phi, theta);
              point.userData.speed = 0.1 + Math.random() * 0.2;
              group.add(point);
              points.push(point);
            }
            
            // Add connection lines
            const lines = [];
            for (let i = 0; i < points.length; i++) {
              for (let j = i + 1; j < points.length; j++) {
                if (Math.random() > 0.7) { // Only connect some points
                  const geometry = new THREE.BufferGeometry().setFromPoints([
                    points[i].position.clone(),
                    points[j].position.clone()
                  ]);
                  const material = new THREE.LineBasicMaterial({
                    color: 0x66e0ff,
                    transparent: true,
                    opacity: 0.3
                  });
                  const line = new THREE.Line(geometry, material);
                  group.add(line);
                  lines.push({
                    line: line,
                    point1: points[i],
                    point2: points[j]
                  });
                }
              }
            }
            
            return {
              model: group,
              points: points,
              lines: lines,
              animate: (time) => {
                // Animate points
                points.forEach((point, i) => {
                  const phi = Math.acos(-1 + (2 * i) / pointCount);
                  const theta = time * point.userData.speed * 0.5 + Math.sqrt(pointCount * Math.PI) * phi;
                  
                  point.position.setFromSphericalCoords(
                    1.6 + Math.sin(time * 0.5 + i) * 0.1,
                    phi + Math.sin(time * 0.3 + i) * 0.1,
                    theta
                  );
                  
                  // Pulsing effect
                  const scale = 0.8 + Math.sin(time * 2 + i) * 0.2;
                  point.scale.set(scale, scale, scale);
                });
                
                // Update lines
                lines.forEach(lineData => {
                  const positions = lineData.line.geometry.attributes.position;
                  positions.setXYZ(0, 
                    lineData.point1.position.x,
                    lineData.point1.position.y,
                    lineData.point1.position.z
                  );
                  positions.setXYZ(1,
                    lineData.point2.position.x,
                    lineData.point2.position.y,
                    lineData.point2.position.z
                  );
                  positions.needsUpdate = true;
                });
                
                group.rotation.y = time * 0.05;
                sphere.rotation.y = time * 0.02;
              }
            };
          }
        }
      };

      const landmarks = [
          {
            position: { x: 0, y: 0, z: 18 },
            lookAt: { x: 0, y: 0, z: 0 },
            title: "BEST Compression",
            description: "ALL Your files shrink by 95% with no quality loss. See how data transforms into a compact, efficient structure.",
            model: 'compression',
            animation: 'float',
            scale: 2.8,
            rotation: { x: 0, y: 0, z: 0 },
            positionOffset: { x: 0, y: 1, z: 0 }
          },
        { 
          position: { x: 12, y: 3, z: 12 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "Decentralized P2P Cloud",
          description: "Your data stays local and fast. Our peer-to-peer architecture means no central servers, just direct device-to-device connections.",
          model: 'network',
          animation: 'float',
          scale: 1.8,
          rotation: { x: 0.2, y: 0, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        },
        { 
          position: { x: -12, y: 4, z: -5 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "Intelligent Bandwidth Optimization",
          description: "Dramatically reduced data usage without compromising quality. Stream HD video on 3G networks with our smart optimization.",
          model: 'bandwidth',
          animation: 'pulse',
          scale: 2,
          rotation: { x: -0.2, y: 0.5, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        },
        { 
          position: { x: 0, y: 8, z: -15 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "5ms Ultra-Low Latency",
          description: "Experience real-time communication like never before. Video calls, messaging, and file transfers with near-zero delay.",
          model: 'latency',
          animation: 'rotate',
          scale: 1.8,
          rotation: { x: 0.3, y: 0, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        },
        { 
          position: { x: -10, y: 6, z: 10 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "Real-time Collaboration",
          description: "Work together seamlessly with our ultra-low latency collaboration tools. Multiple users can edit documents simultaneously with no lag.",
          model: 'collaboration',
          animation: 'float',
          scale: 2,
          rotation: { x: 0, y: 0.5, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        },
        { 
          position: { x: 15, y: 5, z: -5 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "All-in-One File Management",
          description: "Edit, convert, compress, and share files directly in the cloud. No need for additional software - everything is built in.",
          model: 'tools',
          animation: 'rotate',
          scale: 2.2,
          rotation: { x: 0, y: -0.5, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        },
        { 
          position: { x: 0, y: 12, z: 0 }, 
          lookAt: { x: 0, y: 0, z: 0 },
          title: "Military-Grade Encryption",
          description: "End-to-end encryption ensures your data is protected at all times. Not even we can access your files - only you hold the keys.",
          model: 'encryption',
          animation: 'pulse',
          scale: 2.5,
          rotation: { x: 0.4, y: 0, z: 0 },
          positionOffset: { x: 0, y: 1, z: 0 }
        }
      ];

      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0920);
        scene.fog = new THREE.FogExp2(0x0a0920, 0.02); // Lighter fog for better visibility
        
        // Preload first landmark model if not already loaded
        // if (landmarks.length > 0) {
        //   const firstLandmark = landmarks[0];
        //   if (!preloadedModel && models[firstLandmark.model]) {
        //     preloadedModel = models[firstLandmark.model].create();
        //   }
        //   prepareFirstLandmarkModel();
        // }
        
        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        // Camera setup - adjust FOV for mobile
        const cameraFOV = isMobile ? 70 : 75;
        camera = new THREE.PerspectiveCamera(cameraFOV, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20);
        
        // Renderer setup - optimize for mobile
        const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 1.5) : window.devicePixelRatio;
        renderer = new THREE.WebGLRenderer({ 
          antialias: !isMobile, // Disable antialiasing on mobile for better performance
          alpha: true,
          powerPreference: isMobile ? 'default' : 'high-performance',
          precision: isMobile ? 'lowp' : 'mediump'
        });
        
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = !isMobile; // Disable shadows on mobile
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        document.getElementById('scene-container').appendChild(renderer.domElement);

        // Enhanced lighting - optimize for mobile
        const ambientLight = new THREE.AmbientLight(0x404040, isMobile ? 0.6 : 0.5);
        scene.add(ambientLight);

        // Main directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        if (!isMobile) {
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.width = 1024;
          directionalLight.shadow.mapSize.height = 1024;
        }
        scene.add(directionalLight);
        
        // Add some point lights for better 3D effect
        const pointLight1 = new THREE.PointLight(0x66aaff, 1, 50);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff66aa, 1, 50);
        pointLight2.position.set(-10, -10, -10);
        scene.add(pointLight2);

        // Create cloud particles
        createCloudParticles();

        // Create data streams
        createDataStreams();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        
        // Add orbit controls for debugging (can be removed in production)
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.enabled = false; // Disable by default

        // Start animation loop
        animate();

        sceneReady = true;
        attemptJourneyLaunch();
      }
      
      function createCloudParticles() {
        // Detect mobile and reduce particles significantly
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        const particles = isMobile ? 1000 : 5000; // Much fewer particles on mobile
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const color = new THREE.Color();
        
        for (let i = 0; i < particles; i++) {
          // Create a sphere of particles
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const radius = 10 + Math.random() * 10;
          
          positions.push(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );
          
          // Random blue/purple colors
          color.setHSL(
            0.6 + Math.random() * 0.2,
            0.5,
            0.5 + Math.random() * 0.3
          );
          colors.push(color.r, color.g, color.b);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
          size: 0.2,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        objects.push(particleSystem);
      }
      
      function createDataStreams() {
        // Create flowing data streams
        for (let i = 0; i < 3; i++) {
          const curve = new THREE.CubicBezierCurve3(
            new THREE.Vector3(
              Math.random() * 20 - 10,
              Math.random() * 10 - 5,
              Math.random() * 10 - 5
            ),
            new THREE.Vector3(
              Math.random() * 20 - 10,
              Math.random() * 10 - 5,
              Math.random() * 10 - 5
            ),
            new THREE.Vector3(
              Math.random() * 20 - 10,
              Math.random() * 10 - 5,
              Math.random() * 10 - 5
            ),
            new THREE.Vector3(
              Math.random() * 20 - 10,
              Math.random() * 10 - 5,
              Math.random() * 10 - 5
            )
          );
          
          const points = curve.getPoints(50);
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          
          const material = new THREE.LineBasicMaterial({
            color: 0x66e0ff,
            transparent: true,
            opacity: 0.2
          });
          
          const line = new THREE.Line(geometry, material);
          scene.add(line);
          objects.push(line);
        }
      }

      function prepareFirstLandmarkModel() {
        if (!preloadedModel || firstModelPrepared || !scene) return;
        const firstLandmark = landmarks[0];
        const model = preloadedModel.model;
        
        model.position.set(
          firstLandmark.positionOffset?.x || 0,
          firstLandmark.positionOffset?.y || 0,
          firstLandmark.positionOffset?.z || 0
        );
        
        model.rotation.set(
          firstLandmark.rotation?.x || 0,
          firstLandmark.rotation?.y || 0,
          firstLandmark.rotation?.z || 0
        );
        
        const initialScale = firstLandmark.scale || 1;
        model.scale.set(initialScale, initialScale, initialScale);
        model.visible = false;
        scene.add(model);
        currentModel = preloadedModel;
        firstModelPrepared = true;
      }

      function attemptJourneyLaunch() {
        if (sceneReady && quoteIntroReady && !introLaunched) {
          introLaunched = true;
          playFirstLandmarkIntro();
        }
      }

    function playFirstLandmarkIntro() {
      const quoteOverlay = document.getElementById('quote-overlay');
      prepareFirstLandmarkModel();

      // Kill any previous animations
      gsap.killTweensOf(camera.position);
      gsap.killTweensOf(camera.rotation);
      gsap.killTweensOf("*");

      // Fade out quote overlay
      if (quoteOverlay) {
          quoteOverlay.style.willChange = 'opacity, transform';
          quoteOverlay.style.pointerEvents = 'none';
          quoteOverlay.style.backfaceVisibility = 'hidden';
          
          // Optimize fade out for mobile
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
          gsap.to(quoteOverlay, {
              opacity: 0,
              duration: isMobile ? 0.5 : 0.8,
              ease: "power2.inOut",
              onComplete: () => {
                  quoteOverlay.style.display = "none";
                  startJourney();
              }
          });
      } else {
          startJourney();
      }

      // --- FIRST LANDMARK MODEL APPEARANCE ---
      if (preloadedModel && firstModelPrepared && !firstModelVisible) {

          const model = preloadedModel.model;
          const landmark = landmarks[0];

          // Base transform
          model.position.set(
              landmark.positionOffset?.x || 0,
              landmark.positionOffset?.y || 0,
              landmark.positionOffset?.z || 0
          );

          model.rotation.set(0, Math.PI, 0); // flipped start
          model.scale.set(0.2, 0.2, 0.2);     // tiny start
          model.visible = true;
          firstModelVisible = true;

          if (model.parent !== scene) scene.add(model);

          // --- Fade-in: gather all mesh materials ---
          const fadeMaterials = [];
          model.traverse(child => {
              if (child.isMesh) {
                  child.material.transparent = true;
                  child.material.opacity = 0;   // start invisible
                  fadeMaterials.push(child.material);
              }
          });

          // --- CINEMATIC INTRO TIMELINE ---
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
          const targetScale = landmark.scale || 1;

          const tl = gsap.timeline();

          // Faster, simpler animations on mobile
          if (isMobile) {
              tl.to(fadeMaterials, {
                  opacity: 1,
                  duration: 0.5,
                  ease: "power2.out"
              })
              .to(model.rotation, {
                  y: 0,
                  x: 0,
                  duration: 0.6,
                  ease: "power2.out"
              }, "<")
              .to(model.scale, {
                  x: targetScale,
                  y: targetScale,
                  z: targetScale,
                  duration: 0.7,
                  ease: "power2.out"
              }, "<0.1");
          } else {
              tl.to(fadeMaterials, {
                  opacity: 1,
                  duration: 0.8,
                  ease: "power2.out"
              })
              .to(model.rotation, {
                  y: 0,
                  x: -0.4,
                  duration: 1.2,
                  ease: "power3.out"
              }, "<")
              .to(model.scale, {
                  x: targetScale,
                  y: targetScale,
                  z: targetScale,
                  duration: 1.3,
                  ease: "back.out(1.8)"
              }, "<0.1")
              .to(model.rotation, {
                  x: 0,
                  duration: 0.8,
                  ease: "power2.out"
              }, "-=0.4");
          }
      }

      // Overlay performance optimization
      if (quoteOverlay) {
          quoteOverlay.style.willChange = 'opacity, transform';
          quoteOverlay.style.pointerEvents = 'none';
          quoteOverlay.style.backfaceVisibility = 'hidden';
      }
  }

      function startJourney() {
            moveToNextLandmark();
        }

      
      function loadModelForLandmark(landmark, options = {}) {
        if (!models[landmark.model]) return;
        
        const reuseExisting = options.reuseExisting && currentModel && currentModel.model;
        let model = reuseExisting ? currentModel.model : null;
        
        if (!reuseExisting) {
          if (currentModel && currentModel.model) {
            scene.remove(currentModel.model);
          }
          
          currentModel = models[landmark.model].create();
          model = currentModel.model;
        } else {
          gsap.killTweensOf(model.scale);
          gsap.killTweensOf(model.position);
        }
        
        // Apply position, rotation, and scale
        model.position.set(
          landmark.positionOffset?.x || 0,
          landmark.positionOffset?.y || 0,
          landmark.positionOffset?.z || 0
        );
        
        model.rotation.set(
          landmark.rotation?.x || 0,
          landmark.rotation?.y || 0,
          landmark.rotation?.z || 0
        );
        
        const targetScale = landmark.scale || 1;
        
        if (!reuseExisting) {
          model.scale.set(0.01, 0.01, 0.01);
          scene.add(model);
          
          gsap.to(model.scale, {
            x: targetScale,
            y: targetScale,
            z: targetScale,
            duration: 1.1,
            ease: 'back.out(1.4)'
          });
        } else {
          model.scale.set(targetScale, targetScale, targetScale);
        }
      if (landmark.animation === 'float') {
          gsap.to(model.position, {
              y: (landmark.positionOffset?.y || 0) + 0.2,
              duration: 3,
              ease: "sine.inOut",
              yoyo: true,
              repeat: -1
          });
      }

      }
      
      function moveToNextLandmark() {
        if (currentLandmark >= landmarks.length) {
          currentLandmark = 0; // Loop back to start
        }

        // Detect mobile once at the start of the function
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

        const landmark = landmarks[currentLandmark];
        const infoElement = document.getElementById('landmark-info');
        const titleElement = document.getElementById('landmark-title');
        const descElement = document.getElementById('landmark-desc');
        let infoRevealed = false;

        const revealInfo = () => {
          if (infoRevealed) return;
          infoRevealed = true;
          
          // Ensure the model maintains its scale during the transition
          if (currentModel && currentModel.model) {
            const model = currentModel.model;
            const targetScale = landmarks[currentLandmark]?.scale || 1;
            
            // Force set the scale and update the matrix
            model.scale.set(targetScale, targetScale, targetScale);
            model.updateMatrix();
            
            // Add a small scale animation to ensure stability
            gsap.to(model.scale, {
              x: targetScale * 1.02,
              y: targetScale * 1.02,
              z: targetScale * 1.02,
              duration: 0.3,
              yoyo: true,
              repeat: 1,
              ease: 'sine.inOut',
              onUpdate: () => model.updateMatrix()
            });
          }
          
          // Animate the info elements - simpler on mobile
          gsap.to(infoElement, {
            rotationY: isMobile ? 0 : 0,
            opacity: 1,
            duration: isMobile ? 0.3 : 0.55,
            ease: isMobile ? 'power2.out' : 'back.out(1.4)',
            onStart: () => {
              gsap.to(titleElement, {
                rotationY: 0,
                opacity: 1,
                duration: isMobile ? 0.3 : 0.4,
                ease: isMobile ? 'power2.out' : 'back.out(2)'
              });
              
              gsap.to(descElement, {
                rotationY: 0,
                opacity: 1,
                duration: isMobile ? 0.35 : 0.5,
                delay: isMobile ? 0.05 : 0.1,
                ease: isMobile ? 'power2.out' : 'back.out(1.7)'
              });
            }
          });
        };
        
        // Update landmark info with simpler animation on mobile
        gsap.set([titleElement, descElement], { 
          rotationY: isMobile ? 0 : 90,
          opacity: 0,
          transformOrigin: isMobile ? '50% 50%' : '50% 50% -50px',
          perspective: isMobile ? 0 : 1000
        });
        
        // Use preloaded model if it's the first landmark
        if (isFirstLandmark && preloadedModel) {
          currentModel = preloadedModel;
          const model = currentModel.model;
          
          if (!firstModelPrepared) {
            // Set initial position
            model.position.set(
              landmarks[0].positionOffset?.x || 0,
              landmarks[0].positionOffset?.y || 0,
              landmarks[0].positionOffset?.z || 0
            );
            
            // Set initial rotation
            model.rotation.set(
              landmarks[0].rotation?.x || 0,
              landmarks[0].rotation?.y || 0,
              landmarks[0].rotation?.z || 0
            );
            
            // Set and lock the scale
            const targetScale = landmarks[0].scale || 1;
            model.scale.set(targetScale, targetScale, targetScale);
            
            // Prevent any scaling animations
            model.matrixAutoUpdate = false;
            model.updateMatrix();
            
            scene.add(model);
            firstModelPrepared = true;
          } else {
            // Ensure scale remains consistent
            const targetScale = landmarks[0].scale || 1;
            model.scale.set(targetScale, targetScale, targetScale);
            model.updateMatrix();
          }
          
          model.visible = true;
          firstModelVisible = true;
          
          // Add a small delay before revealing info to ensure model is stable
          setTimeout(revealInfo, 100);
          isFirstLandmark = false;
        }
        
        // Animate camera to new position (custom easing for first transition)
        const isFirstTransition = currentLandmark === 0 && !firstTransitionDone;
        // Faster transitions on mobile
        const cameraDuration = isMobile 
          ? (isFirstTransition ? 1.0 : 1.2) 
          : (isFirstTransition ? 1.6 : 1.8);
        const cameraEase = isMobile ? 'power2.inOut' : (isFirstTransition ? 'power3.inOut' : 'power2.inOut');
        const reusePreloadedModel = isFirstTransition && currentModel === preloadedModel;
        
        // Store the original FOV to ensure we return to it
        const originalFov = camera.fov;
        
        gsap.to(camera.position, {
          x: landmark.position.x,
          y: landmark.position.y,
          z: landmark.position.z,
          duration: cameraDuration,
          ease: cameraEase,
          onStart: () => {
            // Skip FOV changes on mobile for better performance
            if (isFirstTransition && !isMobile) {
              // Make the FOV change much more subtle
              const introFov = Math.min(72, camera.fov + 2); // Reduced from +6 to +2
              gsap.fromTo(camera, 
                { fov: introFov },
                { 
                  fov: originalFov, // Use the stored original FOV
                  duration: cameraDuration * 1.2, // Slightly longer for smoother transition
                  ease: 'sine.inOut',
                  onUpdate: () => camera.updateProjectionMatrix()
                }
              );
            }
            // Fade out current model if it exists
            if (currentModel && currentModel.model && !reusePreloadedModel) {
              gsap.to(currentModel.model.scale, {
                x: 0.01,
                y: 0.01,
                z: 0.01,
                duration: isMobile ? 0.6 : 1,
                onComplete: () => {
                  if (currentModel && currentModel.model) {
                    scene.remove(currentModel.model);
                  }
                }
              });
            }
            
            // Hide info with simpler animation on mobile
            gsap.to(infoElement, {
              rotationY: isMobile ? 0 : -90,
              opacity: 0,
              duration: isMobile ? 0.2 : 0.35,
              ease: isMobile ? 'power2.in' : 'back.in',
              onComplete: () => {
                // Update content while hidden
                titleElement.textContent = landmark.title;
                descElement.textContent = landmark.description;
                if (isFirstTransition) {
                  revealInfo();
                }
              }
            });
          },
          onUpdate: () => {
            camera.lookAt(
              landmark.lookAt.x,
              landmark.lookAt.y,
              landmark.lookAt.z
            );
          },
          onComplete: () => {
            if (isFirstTransition) {
              firstTransitionDone = true;
            }
            // Load and animate the 3D model for this landmark
            loadModelForLandmark(landmark, { reuseExisting: reusePreloadedModel });
            
            // Show info with 3D flip animation (if not already shown)
            revealInfo();

            // Move to next landmark after a delay - shorter on mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            setTimeout(() => {
                  currentLandmark++;
                  moveToNextLandmark();
            }, isMobile ? 3000 : 4000);
          }
        });
      }
      
      function onWindowResize() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        // Update pixel ratio on resize for mobile
        const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 1.5) : window.devicePixelRatio;
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        // Animate the current 3D model if it exists
        if (currentModel && currentModel.animate) {
          currentModel.animate(time);
        }
        
        // Update any animations from the mixer
        if (mixer) {
          mixer.update(delta);
        }
        
        // Rotate all base objects slightly - slower on mobile
        objects.forEach(obj => {
          if (obj.rotation) {
            obj.rotation.x += isMobile ? 0.0002 : 0.0005;
            obj.rotation.y += isMobile ? 0.0005 : 0.001;
          }
        });
        
        renderer.render(scene, camera);
      }
      
      // Show quote immediately when page loads
      document.addEventListener('DOMContentLoaded', function() {
        const quoteOverlay = document.getElementById('quote-overlay');
        const quoteCard = quoteOverlay?.querySelector('.quote-card');
        const quoteDivider = quoteOverlay?.querySelector('.quote-divider');
        
        // Start preloading immediately
        if (landmarks.length > 0 && models[landmarks[0].model]) {
          preloadedModel = models[landmarks[0].model].create();
        }
        
        if (!quoteOverlay || !quoteCard) {
          quoteIntroReady = true;
          attemptJourneyLaunch();
          return;
        }
        
        // Detect mobile for optimized animations
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        gsap.set(quoteCard, { opacity: 0, y: isMobile ? 20 : 30, scale: 0.95 });
        if (quoteDivider) {
          gsap.set(quoteDivider, { scaleX: 0 });
        }
        
        const quoteTimeline = gsap.timeline({ delay: 0.05 });
        quoteTimeline
          .to(quoteCard, {
            duration: isMobile ? 0.4 : 0.55,
            opacity: 1,
            y: 0,
            scale: 1,
            ease: isMobile ? 'power2.out' : 'power3.out'
          });
        
        if (quoteDivider) {
          quoteTimeline.to(quoteDivider, {
            duration: isMobile ? 0.35 : 0.5,
            scaleX: 1,
            ease: 'power2.out'
          }, isMobile ? '-=0.3' : '-=0.4');
        }
        
        // Shorter wait time on mobile
        quoteTimeline
          .to({}, { duration: isMobile ? 1.5 : 2 })
          .add(() => {
            // Reduced float animation on mobile
            if (isMobile) {
              quoteFloatTween = gsap.to(quoteCard, {
                duration: 1.5,
                y: '+=5',
                repeat: -1,
                yoyo: true,
                ease: 'sine.inOut'
              });
            } else {
              quoteFloatTween = gsap.to(quoteCard, {
                duration: 1.2,
                y: '+=8',
                repeat: -1,
                yoyo: true,
                ease: 'sine.inOut'
              });
            }
            quoteIntroReady = true;
            attemptJourneyLaunch();
          });
      });

      // Start the 3D scene after the page loads
      window.addEventListener('load', init);
    </script>

    <script>
  const canvas = document.getElementById("background-particles");
  const ctx = canvas.getContext("2d");

  let w, h, particles = [];

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  function createParticles() {
    particles = [];
    for (let i = 0; i < 160; i++) {
      particles.push({
        x: (Math.random() - 0.5) * w,
        y: (Math.random() - 0.5) * h,
        z: Math.random() * 3 + 1,          // "depth"
        size: Math.random() * 2 + 0.5,
        baseAngle: Math.random() * Math.PI * 2,
        rotSpeed: 0.0005 + Math.random() * 0.001,
        color: [
          "#a86bff",
          "#ff5fb7",
          "#66e0ff"
        ][Math.floor(Math.random()*3)]
      });
    }
  }
  createParticles();

  function glowCircle(x, y, size, color) {
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 4);
    gradient.addColorStop(0, color + "aa");
    gradient.addColorStop(1, color + "00");

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size * 4, 0, Math.PI * 2);
    ctx.fill();
  }

  function animateparticles() {
    ctx.clearRect(0,0,w,h);
    ctx.globalCompositeOperation = "lighter";   // ✨ glow like your 3D scene

    const t = performance.now();

    particles.forEach(p => {
      // Orbital motion similar to your intro
      const angle = p.baseAngle + t * p.rotSpeed;
      const radius = 160 * p.z;

      const screenX = w/2 + Math.cos(angle) * radius;
      const screenY = h/2 + Math.sin(angle) * radius * 0.55; 

      // Z depth scales size
      const finalSize = p.size * (2 / p.z);

      glowCircle(screenX, screenY, finalSize, p.color);
      
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(screenX, screenY, finalSize, 0, Math.PI*2);
      ctx.fill();
    });

    requestAnimationFrame(animateparticles);
  }

  animateparticles();
  </script>
  <script>
    // Scroll Indicator + Scroll Transition
  const scrollIndicator = document.getElementById("scroll-indicator");
  const heroSection = document.querySelector(".smooth-hero");

  scrollIndicator.addEventListener("click", () => {
    scrollIndicator.classList.add("hidden");

    window.scrollTo({
      top: heroSection.offsetTop,
      behavior: "smooth"
    });
  });

  // Fade indicator away once user scrolls a little
  window.addEventListener("scroll", () => {
    if (window.scrollY > 50) {
      scrollIndicator.classList.add("hidden");
    }
  });
  // Parallax blend between intro → hero
  window.addEventListener("scroll", () => {
    const sc = window.scrollY;
    const hero = document.querySelector(".smooth-hero");

    // Move hero upward slightly for the “slide into place” effect
    hero.style.transform = `translateY(${Math.max(0, 60 - sc * 0.15)}px)`;

    // Fade in smoothly as user scrolls down
    const opacity = Math.min(1, sc / 250);
    hero.style.opacity = opacity;
  });

  </script>
  <script>
    // Plan card click handlers
    document.addEventListener('DOMContentLoaded', function() {
      // Get all plan cards
      const planCards = document.querySelectorAll('.card[style*="background: linear-gradient"]');
      
      // Add click handler to each plan card
      planCards.forEach(card => {
        card.style.cursor = 'pointer';
        card.addEventListener('click', function() {
          // Get the plan type from the card
          const planType = this.querySelector('h3')?.textContent.trim().toLowerCase();
          if (planType) {
            // Set the plan in the form
            const planSelect = document.getElementById('plan');
            for (let option of planSelect.options) {
              if (option.text.toLowerCase().includes(planType)) {
                planSelect.value = option.value;
                break;
              }
            }
            
            // Scroll to form
            const form = document.getElementById('appForm');
            if (form) {
              form.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              // Highlight the form
              form.style.animation = 'pulse 1s';
              setTimeout(() => {
                form.style.animation = '';
              }, 1000);
            }
          }
        });
      });
      
      // Add pulse animation for highlighting
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(102, 224, 255, 0.4); }
          70% { box-shadow: 0 0 0 10px rgba(102, 224, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(102, 224, 255, 0); }
        }
    /* --- MOBILE FIX FOR QUOTE CARD --- */
  @media (max-width: 600px) {

    #quote-overlay {
      top: 55% !important;
      transform: translate(-50%, -50%) !important;
      width: 100%;
      max-width: 95% !important;
      padding: 0 10px;
    }

    .quote-card {
      padding: 28px 20px !important;
      border-radius: 18px !important;
      max-width: 100% !important;
      transform: translateY(0) scale(1) !important;
    }

    .quote-card p:first-child {
      font-size: 1.35rem !important;
      line-height: 1.35 !important;
      margin-bottom: 14px !important;
    }

    .quote-divider {
      width: 70px !important;
      height: 3px !important;
      margin-bottom: 14px !important;
    }

    .quote-card p:last-child {
      font-size: 0.95rem !important;
      line-height: 1.45 !important;
    }
  }

  /* For *very* small phone screens */
  @media (max-width: 380px) {
    .quote-card p:first-child {
      font-size: 1.2rem !important;
    }
  }

      `;
      document.head.appendChild(style);

      // Enhanced scroll indicator functionality
      const scrollIndicator = document.getElementById("scroll-indicator");
      const heroSection = document.querySelector(".smooth-hero");

      if (scrollIndicator && heroSection) {
        // Click handler
        scrollIndicator.addEventListener('click', function() {
          heroSection.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
          });
        });

        // Touch handler for mobile
        scrollIndicator.addEventListener('touchend', function(e) {
          e.preventDefault();
          heroSection.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
          });
        });

        // Hide on scroll
        window.addEventListener("scroll", () => {
          if (window.scrollY > 50) {
            scrollIndicator.classList.add("hidden");
          }
        });
      }

      // Mobile optimization for intro animation
      if (window.innerWidth <= 600) {
        // Reduce the number of particles for mobile
        const particleElements = document.querySelectorAll('.particle');
        if (particleElements.length > 50) {
          for (let i = 50; i < particleElements.length; i++) {
            particleElements[i].remove();
          }
        }
        
        // Optimize the quote card for mobile
        const quoteCard = document.querySelector('.quote-card');
        if (quoteCard) {
          quoteCard.style.padding = '30px 20px';
          quoteCard.style.width = '90%';
          quoteCard.style.maxWidth = '90%';
        }
      }
    });

  </script>


  </body>
